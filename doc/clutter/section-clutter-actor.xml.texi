
@c %start of fragment

@node ClutterActor
@chapter ClutterActor
Base abstract class for all visual stage actors.

@section Overview
@code{<clutter-actor>} is a base abstract class for all visual elements
on the stage. Every object that must appear on the main
@code{<clutter-stage>} must also be a @code{<clutter-actor>}, either by
using one of the classes provided by Clutter, or by implementing a new
@code{<clutter-actor>} subclass.

Every actor is a 2D surface positioned and optionally transformed in 3D
space. The actor is positioned relative to top left corner of it parent
with the childs origin being its anchor point (also top left by
default).

@section Actor bounding box and transformations
Any actor's 2D surface is contained inside its bounding box, as
described by the @code{<clutter-actor-box>} structure:

@c (title "Bounding box of an Actor")
The actor box represents the untransformed area occupied by an actor.
Each visible actor that has been put on a @code{<clutter-stage>} also
has a transformed area, depending on the actual transformations applied
to it by the developer (scale, rotation). Tranforms will also be applied
to any child actors. Also applied to all actors by the
@code{<clutter-stage>} is a perspective transformation. API is provided
for both tranformed and untransformed actor geometry information.

The GL 'modelview' transform matrix for the actor is constructed from
the actor settings by the following order of operations:

@enumerate 
@item
@item
@item
@item
@item
@item
@item
@item
@end enumerate

Translation by actor x, y coords,

Translation by actor depth (z),

Scaling by scale_x, scale_y,

Rotation around z axis,

Rotation around y axis,

Rotation around x axis,

Negative translation by anchor point x, y,

Rectangular Clip is applied (this is not an operation on the matrix as
such, but it is done as part of the transform set up).

An actor can either be explicitly sized and positioned, using the
various size and position accessors, like @code{clutter-actor-set-x} or
@code{clutter-actor-set-width}; or it can have a preferred width and
height, which then allows a layout manager to implicitly size and
position it by "allocating" an area for an actor. This allows for actors
to be manipulated in both a fixed (or static) parent container (i.e.
children of @code{<clutter-group>}) and a more automatic (or dynamic)
layout based parent container.

When accessing the position and size of an actor, the simple accessors
like @code{clutter-actor-get-width} and @code{clutter-actor-get-x} will
return a value depending on whether the actor has been explicitly sized
and positioned by the developer or implicitly by the layout manager.

Depending on whether you are querying an actor or implementing a layout
manager, you should either use the simple accessors or use the size
negotiation API.

@section Event Handling
Clutter actors are also able to receive input events and react to them.
Events are handled in the following ways:

@enumerate 
@item
@item
@item
@item
@item
@item
@item
@item
@end enumerate

Actors emit pointer events if set reactive, see
@code{clutter-actor-set-reactive}

The stage is always reactive

Events are handled by connecting signal handlers to the numerous event
signal types.

Event handlers must return @samp{@code{#t}} if they handled the event
and wish to block the event emission chain, or @samp{@code{#f}} if the
emission chain must continue

Keyboard events are emitted if actor has focus, see
@code{clutter-stage-set-key-focus}

Motion events (motion, enter, leave) are not emitted if
@code{clutter-set-motion-events-enabled} is called with
@samp{@code{#f}}. See @code{clutter-set-motion-events-enabled}
documentation for more information.

Once emitted, an event emission chain has two phases: capture and
bubble. An emitted event starts in the capture phase (see
ClutterActor::captured-event) beginning at the stage and traversing
every child actor until the event source actor is reached. The emission
then enters the bubble phase, traversing back up the chain via parents
until it reaches the stage. Any event handler can abort this chain by
returning @samp{@code{#t}} (meaning "event handled").

Pointer events will 'pass through' non reactive overlapping actors.

@c (title "Event flow in Clutter")
Every '?' box in the diagram above is an entry point for application
code.

@section Implementing a ClutterActor
For implementing a new custom actor class, please read the corresponding
section of the API reference.

@section ClutterActor custom properties for @code{<clutter-script>}
@code{<clutter-actor>} defines a custom "rotation" property which allows
a short-hand description of the rotations to be applied to an actor.

The syntax of the "rotation" property is the following:

@example 

"rotation" : [
  @{ "<axis>" : [ <angle>, [ <center> ] ] @}
]
    
@end example

where the @emph{axis} is the name of an enumeration value of type
@code{<clutter-rotate-axis>} and @emph{angle} is a floating point value
representing the rotation angle on the given axis, in degrees.

The @emph{center} array is optional, and if present it must contain the
center of rotation as described by two coordinates: Y and Z for
"x-axis"; X and Z for "y-axis"; and X and Y for "z-axis".

@code{<clutter-actor>} will also parse every positional and dimensional
property defined as a string through @code{clutter-units-from-string};
you should read the documentation for the @code{<clutter-units>} parser
format for the valid units and syntax.

@section Custom animatable properties
@code{<clutter-actor>} allows accessing properties of
@code{<clutter-action>} and @code{<clutter-constraint>} instances
associated to an actor instance for animation purposes.

In order to access a specific @code{<clutter-action>} or a
@code{<clutter-constraint>} property it is necessary to set the
@code{<"name">} property on the given action or constraint.

The property can be accessed using the following syntax:

@example 

@@<section>.<meta-name>.<property-name>
    
@end example

The initial @emph{@@} is mandatory.

The @emph{section} fragment can be one between "actions", "constraints"
and "effects".

The @emph{meta-name} fragment is the name of the action or constraint,
as specified by the @code{<"name">} property.

The @emph{property-name} fragment is the name of the action or
constraint property to be animated.

@c (example (@ (id "example-ClutterActor-animating-meta")))
@c (title "Animating a constraint property")
The example below animates a @code{<clutter-bind-constraint>} applied to
an actor using @code{clutter-actor-animate}. The @emph{rect} has a
binding constraint for the @emph{origin} actor, and in its initial state
is fully transparent and overlapping the actor to which is bound to.

@example 

constraint = clutter_bind_constraint_new (origin, CLUTTER_BIND_X, 0.0);
clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), "bind-x");
clutter_actor_add_constraint (rect, constraint);

constraint = clutter_bind_constraint_new (origin, CLUTTER_BIND_Y, 0.0);
clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), "bind-y");
clutter_actor_add_constraint (rect, constraint);

clutter_actor_set_reactive (rect, TRUE);
clutter_actor_set_opacity (rect, 0);

g_signal_connect (rect, "button-press-event",
                  G_CALLBACK (on_button_press),
                  NULL);
    
@end example

On button press, the rectangle "slides" from behind the actor to which
is bound to, using the @code{<"offset">} property and the
@code{<"opacity">} property.

@example 

float new_offset = clutter_actor_get_width (origin) + h_padding;

clutter_actor_animate (rect, CLUTTER_EASE_OUT_CUBIC, 500,
                       "opacity", 255,
                       "@@constraints.bind-x.offset", new_offset,
                       NULL);
    
@end example

@section Usage
@include defuns-clutter-actor.xml.texi

@c %end of fragment
